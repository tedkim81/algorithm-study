/**
 * 2019.4.2
 *
 * N마리의 개미가 있고, 공중에서 먹이로 유인했더니 개미들이 서로가 서로를 밟고 올라가 먹이를 따내고자 한다.
 * 개미는 한줄로 올라가고(개미 위로 한마리 아래로 한마리), 위로는 자신의 무게의 6배까지 버틸 수 있다.
 * 그리고 더 길이가 긴 개미가 아래쪽에 있어야 한다.
 * 그렇다면, N마리의 개미의 무게가 주어지고, 길이 순서대로 줄서있는 상황에서, 최적의 조합으로 개미탑이 쌓아졌을때
 * 최대 몇마리가 될 수 있나?
 *
 * (input)
 * T: 테스트케이스의 수
 * N: 개미의 수
 * W[0],...,W[N-1]: 각 개미의 무게. 개미의 몸 길이 오름차순으로 나열됨.
 *
 * (output)
 * 개미탑의 최대 크기(개미 몇마리?)
 *
 * (solution 1)
 * 일단은 심플하게 먼저 생각해보자.
 * 실제로 개미는 아래에서부터 위로 쌓여올라가겠지만, 반대로 위에서부터 생각하는게 알고리즘 작성하기가 수월하다.
 * 길이가 짧은 개미(먼저 입력받은 개미)부터, 선택하거나 하지 않거나를 결정하면서 탐색하고, 선택된 개미의 수가 가장 많을때를 찾자.
 * 그런데 이 방식은 복잡도가 O(2의 N제곱) 이기 때문에, N이 100인 Test set 1도 실행할 수가 없다.
 * 그렇다면 두가지 관점에서 더 생각해보자. 선택을 덜하기(가지치기), 그리고 메모이제이션.
 * - 탐색 중에, 그때까지의 개미의 무게합이 현재 개미 무게의 6배보다 크면 자연히 걔는 선택할 수가 없다.
 * - Test set 1에 대하여, W 최대값이 1000이므로 이전 개미의 무게합이 6000을 넘으면 더 탐색할 필요가 없다.
 * - 6 1 1 1 1 1 1 1 의 경우에는 6을 선택하지 않아야 하고, 6 1 2 의 경우에는 6을 선택해야 한다. 
 * - 
 */

#include <stdio.h>
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
	int T;
	cin >> T;
	for (int i=0; i<T; i++) {
		
	}
}